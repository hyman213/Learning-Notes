# 数据结构01 算法的时间复杂度和空间复杂度

## **1. 算法的概念**

算法（Algorithm）是指用来操作数据、解决程序问题的一组方法。对于同一个问题，使用不同的算法，也许最终得到的结果是一样的，但在过程中消耗的资源和时间却会有很大的区别。

## **2. 衡量算法的指标**

**（1）时间复杂度：** 是指执行当前算法所消耗的时间

**（2）空间复杂度：** 是指执行当前算法需要占用多少内存空间

　　同一个问题可以用不同的算法解决，而一个算法的优劣将影响到算法乃至程序的效率。算法分析的目的在于为特定的问题选择合适算法。**一个算法的评价主要从时间复杂度和空间复杂度来考虑**

　　**算法在时间的高效性和空间的高效性之间通常是矛盾的** 。所以一般只会取一个平衡点。通常我们假设程序运行在足够大的内存空间中，**所以研究更多的是算法的时间复杂度。**

## 3. 算法的时间复杂度

### 3-1. 基本概念

**（1）语句频度T(n)：**  一个算法执行所花费的时间，从理论上是不能算出来的，必须上机运行测试才能知道。但我们不可能对每个算法都上机测试，只需知道哪个算法花费的时间多，哪个算法花费的时间少就可以了。而且一个算法花费的时间与算法中的基本操作语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。**一个算法中的语句执行次数称为语句频度，记为T(n)**

  **（2）时间复杂度：** 在刚才提到的语句频度中，n称为问题的规模，当n不断变化时，语句频度T(n)也会不断变化。但有时我们想知道它的变化呈现什么规律。为此，我们引入时间复杂度概念。 一般情况下，算法中的基本操作语句的重复执行次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n)，使得当n趋近于无穷大时，T(n) / f(n) 的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作 T(n)=Ｏ( f(n) )，称**Ｏ( f(n) )  为算法的渐进时间复杂度，简称时间复杂度 - 大O符号表示法。** T(n) 不同，但时间复杂度可能相同。 如：T(n)=n²+5n+6 与 T(n)=3n²+3n+2 它们的T(n) 不同，但时间复杂度相同，都为O(n²)

**示例**

```java
for(i=1; i<=n; ++i){
   j = i;
   j++;
}

/*
假设每行代码的执行时间都是一样的，我们用 1颗粒时间 来表示，那么这个例子的第一行耗时是1个颗粒时间，第三行的执行时间是 n个颗粒时间，第四行的执行时间也是 n个颗粒时间（第二行和第五行是符号，暂时忽略），那么总时间就是 1颗粒时间 + n颗粒时间 + n颗粒时间 ，即 (1+2n)个颗粒时间，即： T(n) = (1+2n)*颗粒时间，从这个结果可以看出，这个算法的耗时是随着n的变化而变化，因此，我们可以简化的将这个算法的时间复杂度表示为：T(n) = O(n)
*/
```

**（3）平均时间复杂度和最坏时间复杂度**

平均时间复杂度是指所有可能的输入实例均以等概率出现的情况下，该算法的运行时间。      

**最坏情况下的时间复杂度称最坏时间复杂度。一般讨论的时间复杂度均是最坏情况下的时间复杂度。** 这样做的原因是：最坏情况下的时间复杂度是算法在任何输入实例上运行时间的界限，这就保证了算法的运行时间不会比最坏情况更长。     

### 3-2. 常见的时间复杂度

- **常数阶O(1)**

- **对数阶O(log<sub>2</sub>n)**

- **线性阶O(n)**

- **线性对数阶O(nlog<sub>2</sub>n)**

- **平方阶O(n<sup>2</sup>)**

- **立方阶O(n<sup>3</sup>)**

- **k次方阶O(n<sup>k</sup>)**

- **指数阶O(2<sup>n</sup>)**

  随着问题规模n的不断增大，上述时间复杂度不断增大，算法的执行效率越低。

#### 3-2-1. 常数阶O(1)

无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是O(1)

```java
int i = 1;
int j = 2;
++i;
j++;
int m = i + j;
```

#### 3-2-2. 对数阶O(log<sub>2</sub>n)

当循环 **log<sub>2</sub>n** 次以后，这个代码就结束了

```javascript
int i = 1;
while(i<n)
{
    i = i * 2;
}

/*
在while循环里面，每次都将 i 乘以 2，乘完之后，i 距离 n 就越来越近了。我们试着求解一下，假设循环x次之后，i 就大于 2 了，此时这个循环就退出了，也就是说 2 的 x 次方等于 n，那么 x = log2^n
*/
```

#### 3-2-3. 线性阶O(n)

```java
for(i=1; i<=n; ++i)
{
   j = i;
   j++;
}
```

for循环里面的代码会执行n遍，因此它消耗的时间是随着n的变化而变化的，因此这类代码都可以用O(n)来表示它的时间复杂度。

#### 3-2-4. 线性对数阶nlog<sub>2</sub>n

线性对数阶O(nlog<sub>2</sub>n) 其实非常容易理解，将时间复杂度为O(log<sub>2</sub>n)的代码循环n遍的话，那么它的时间复杂度就是 n * O(log<sub>2</sub>n)，也就是了O(nlog<sub>2</sub>n)

```java
for(m=1; m<n; m++){
    i = 1;
    while(i<n)
    {
        i = i * 2;
    }
}
```

#### 3-2-5. 平方阶O(n<sup>2</sup>)

如果把 O(n) 的代码再嵌套循环一遍，它的时间复杂度就是 O(n²) 了。

```java
for(x=1; i<=n; x++){
   for(i=1; i<=n; i++){
       j = i;
       j++;
    }
}
```

#### 3-2-6. 立方阶O(n<sup>3</sup>)

参考上面的O(n²) 去理解就好了，O(n³)相当于三层n循环

#### 3-2-7. k次方阶O(n<sup>k</sup>)

O(n<sup>k</sup>)相当于k层n循环


#### 3-2-8. 指数阶O(2<sup>n</sup>)



### 3-3. 如何求时间复杂度

**【1】如果算法的执行时间不随着问题规模n的增加而增长，即使算法中有上千条语句，其执行时间也不过是一个较大的常数。此类算法的时间复杂度是O(1)**

```java
public static void main(String[] args) {
    int x = 91;
    int y = 100;
    while (y > 0) {
        if (x > 100) {
            x = x - 10;
            y--;
        } else {
            x++;
        }
    }
}
```

这段程序的运行是和n无关的，就算它再循环一万年，我们也不管他，只是一个常数阶的函数        

**【2】当有若干个循环语句时，算法的时间复杂度是由嵌套层数最多的循环语句中最内层语句的频度f(n)决定的**  

```java
int x = 1;
for (int i = 1; i <= n; i++) {
	for (int j = 1; j <= i; j++) {
		for (int k = 1; k <= j; k++) {
			x++;
		}
	}
}
```


该算法的时间复杂度为：O(n<sup>3</sup>)   该程序段中频度最大的语句是第5行的语句，内循环的执行次数虽然与问题规模n没有直接关系，但是却与外层循环的变量取值有关，而最外层循环的次数直接与n有关，因此该程序段的时间复杂度为 O(n<sup>3</sup>)     

**【3】算法的时间复杂度不仅仅依赖于问题的规模，还与输入实例的初始状态有关**

在数值 A[n-1，n-2 ...0] 中查找给定值k的算法大致如下：      

```java
int i = n - 1;
while (i >= 0 && (A[i] != k)) {
	i--;
}
return i;
```


该算法的时间复杂度为：O(n)  　

此算法中第3行语句的频度不仅与问题规模n有关，还与输入实例A中的各元素取值和k的取值有关：如果A中没有与k相等的元素，那么第3行语句的频度为 f(n)=n ，该程序段的时间复杂度为 O(n)           

### 3-4. 用时间复杂度来评价算法的性能

用两个算法A<sub>1</sub>和A<sub>2</sub>求解同一问题，时间复杂度分别是O(100n<sup>2</sup>)，O(5n<sup>3</sup>)   

（1） 5n<sup>3</sup>/100n<sup>2</sup>=n/20 ，当输入量n＜20时，100n<sup>2</sup>> 5n<sup>3</sup> ，这时A<sub>2</sub>花费的时间较少。 　　　　   

（2）随着问题规模n的增大，两个算法的时间开销之比 5n<sup>3</sup>/100n<sup>2</sup>=n/20 也随着增大。即当问题规模较大时，算法A<sub>1</sub>比算法A<sub>2</sub>要高效的多。**它们的渐近时间复杂度O(n<sup>2</sup>)和O(n<sup>3</sup>) 评价了这两个算法在时间方面的性能。在算法分析时，往往对算法的时间复杂度和渐近时间复杂度不予区分**，而经常是将渐近时间复杂度 O(f(n)) 简称为时间复杂度，其中的f(n)一般是算法中频度最大的语句频度。   

## 4. 算法的空间复杂度　　

　　**空间复杂度(Space Complexity) 是对一个算法在运行过程中临时占用存储空间大小的量度，记做 S(n)=O(f(n)) ，其中n为问题的规模**。利用算法的空间复杂度，可以对算法的运行所需要的内存空间有个预先估计。 

  一个算法执行时除了需要存储本身所使用的指令、常数、变量和输入数据外，还需要一些对数据进行操作的工作单元和存储一些计算所需的辅助空间。算法执行时所需的存储空间包括以下两部分。

  （1）固定部分。这部分空间的大小与输入/输出的数据的个数、数值无关。主要包括指令空间（即代码空间）、数据空间（常量、简单变量）等所占的空间。这部分属于静态空间。

  （2）可变空间，这部分空间的主要包括动态分配的空间，以及递归栈所需的空间等。这部分的空间大小与算法有关。

空间复杂度比较常用的有：O(1)、O(n)、O(n²)

1. **空间复杂度 O(1)**

```java
int i = 1;
int j = 2;
++i;
j++;
int m = i + j;
```

如果算法执行所需要的临时空间不随着某个变量n的大小而变化，即此算法空间复杂度为一个常量

2. **空间复杂度 O(n)**

```java
int[] m = new int[n]
for(i=1; i<=n; ++i)
{
   j = i;
   j++;
}
```

这段代码中，第一行new了一个数组出来，这个数据占用的大小为n，这段代码的2-6行，虽然有循环，但没有再分配新的空间，因此，这段代码的空间复杂度主要看第一行即可，即 S(n) = O(n)

## 5. 总结

算法的时间复杂度和两个因素有关：算法中的最大嵌套循环层数；最内层循环结构中循环的次数。     

一般来说，具有多项式时间复杂度的算法是可以接受的；具有指数（不是对数）时间复杂度的算法，只有当n足够小时才可以使用。一般效率较好的算法要控制在O(log<sub>2</sub>n) 或者 O(n)    




